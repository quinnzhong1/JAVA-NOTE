# 第十三章 反射


## ClassLoader
* ClassLoader：把class加载到内存中
![](./picture/classLoader.png)
![](./picture/classloader_class_load.png)
![](./picture/jdk_class_loader.png)
* bootstrap class loader是最顶层，一般用c语言之类的写的
  * 调用: `*.class.getClassLoader()`
* extention class loader 是扩展类
    * `*.class.getClassLoader().getClass().getName()`
* Application class loader
    * `ClassLoader.getSystemClassLoader()`
* ClassLoader层次关系：
![](./picture/jdk_classLoader_levels.png)
  * 每个classloader里面有一个引用都是指向上一层的classloader
  * 可以打印出来
```java
ClassLoder c = JDKClassLoaderTest.class.getClassLoader();
while (c != null) {
    System.out.println(c.getClass().getName());
    c = c.getParent();
}
```

## 反射Reflection
* 一个class里面的方法属于对象，属性也属于对象
* `java.lang.reflect.Field` `java.lang.reflect.Method`
* 举例
```java
public class TestReflection throws ClassNotDoundException, InstantiationException, IlligalAccessException, IllegalArgumentException{
    public static void main(String[] args) {
        String str = "T";
        try {
            //动态调用class
            Class c = Class.ForName(str);
            //动态建立一个对象
            Object o = c.newInstance();
            //动态获取这个类的方法
            Method[] methods = c.getMethods();
            //遍历该方法
            for(Method m : methods) {
                System.out.println(m.getName());
                if(m.getName().equals("mm")) {
                    //invoke该方法，必须传一个该对象进去
                    m.invoke(o);
                    //invoke是个可变参数方法 - invoke(Object o, Object... args)
                }
                if(m.getName.equals("m1")) {
                    m.invoke(o, 1);
                    // m.getParameterTypes();
                }
            }
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
        
    }
}

class T {
    static {
        System.out.println("T loaded");
    }
    public T() {
        System.out.println("T constructed");
    }

    int i;
    String s;
    public void m1(int i) {
        this.i = i;
        System.out.println(i);
    }

    public void mm() {
        System.out.println("m invoked");
    }

    public String getS() {
        return s;
    }
}
```
建立一个test.properties
```
Class=T
把这句话读取出来生成一个T
```
* 反射定义：通过反射接口，可以动态地了解一个class的内部结构，并且根据这个内部结构，来决定如何调用class
* 运行期间，动态地加载一个类进来，动态地new一个对象出来，动态地了解一个对象内部的结构，动态地调用这个对象的一些方法，可以查一个方法有几个参数，可以查到它的return类型等等
* 好处：配置文件比如properties，直接写个类名进去，之后就可以动态加载了。这样可拓展性增加

## 代码示例
```java
//封装打折策略
public class Order {
    private String productName = null;
    private int count = 0;
    private int unitPrice = 0;
    //假设都有get和set方法，这里懒得写了

    // private double discount = 1.0; // 这个太死板了，相当于定死，没法设计复杂的打折策略

    public int getTotalPrice() {
        return count * unitPrice;
    }

    @Override
    public String toString() {
        return productName + "-" + getTotalPrice();
    }



    public static void main(String[] args) {
        Order o = new Order();
        o.setProductName("apple");
        o.setCount(10);
        o.setUnitPrice(2);
        System.out.println(o);
    }
}
```



