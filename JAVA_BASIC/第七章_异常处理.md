# 第七章 异常处理

## 概述

* **理解**
  * 异常对象都是派生于Throwable类的一个实例
  * 遇到各种出现的问题，可以自己写报错内容
  * 执行程序中的不正常现象称为异常
  * 异常事件分类
    * Error
      * 虚拟机无法解决的严重问题，一般无法自行解决
      * 一般不进行代码处理
      * 举例
        * java.lang.StackOverFlowError - stack
        * java.lang.OutOfMemoryError - heap
        * 资源耗尽
        * JVM系统内部错误
    * Exception
      * 因为编程错误或者偶然外在因素导致的一般性问题，可以使用针对性代码处理
      * 举例
        * 空指针访问
        * 数组角标越界
        * 读取不存在的文件
        * 网络连接中断
  * 解决方案
    * 方法一
      * 终止运行
    * 方法二
      * 编写程序，考虑到错误的检测或者错误消息的提示，或者错误的处理
  * 捕获错误
    * 最好在编译期间，但有的只能在运行时出现
    * 分类
      * 编译时异常 - 执行javac.exe时，出现的异常
      * 运行时异常 - 执行java.exe出现的异常
  * ![](picture/exception_note.png)
  * RunTimeException 和 Error，没必要声明
  * check的exception必须声明，即编译时异常
  * RuntimeException可处理可不处理，因为系统一般会自动抛出，其他exception必须捕捉处理

## 异常结构体系

* Throwable
  * Error（unchecked）
  * Exception
    * checked 编译异常
      * IOException
        * FileNotFoundException
      * ClassNotFound
    * unchecked 运行异常 （RuntimeException）
      * NullPointerException
      * ArrayIndexOutOfBoundsException
      * ClassCastException
      * NumberFormatException
      * InputMismatchException
      * ArithmeticException

## 常见异常举例

```java
// NullPointerException
int[] arr = null;
sout(arr);

// InputMismatchException
Scanner s = new Scanner(System.in);
int score = s.nextInt();//input abc
sout(score);

// NumberFormatException
String str = "abc";
int num = Integer.parseInt(str);

//ArithmeticException
int i = 10 / 0;

// FileNotFoundException
File f = new File("hello.txt");
FileInputStream fis = new FileInputStream(file);

int data = fis.read();
while(data != -1) {
    sout((char)data);
    data = fis.read();
}

fis.close();
```

## 异常处理机制

* 过程一：“抛”：异常 - 异常代码生成一个对应异常类 - 抛出 - 之后代码不执行
  
  异常对象产生：
  1. 系统自动生成异常对象
  2. 手动生成一个异常对象，抛出（throw） e.g. ```throw new Exception("Wrong!")```
* 过程二：“抓”：异常处理
  1. try-catch-finally
  2. throws

### 一：try-catch-finally

```java
try{
    //possible code creating exception
} catch(Exception1 var1) {
    //handle 1
    sout("Exception1: ...");
} catch(Exception2 var2) {
    //handle 2
}
...
finally{
    // code that would be implemented
    // Optional
    sout("End of the Program");
}
```
* 异常能够被try-catch结构处理掉
* 一旦出现异常并被catch抓住，就跳出结构（除非有finally),继续执行其他代码
* 如果异常有父子类关系，子类一定要在上面，否则报错（没有父子关系，则谁在上运行谁）
* 打印异常
  * 自己写
  * `sout(e.getMessage())`
  * `e.printStackTrace()`
* finally - 最后一定执行的代码
  * 数据库连接、输入输出流、网络编程socket等资源，jvm不能自动回收的，需要手动回收资源释放 - finally
  * ![](./picture/finally_cases.png)
* 该结构可以嵌套写，比如finally里可以继续写try-catch
* 编译时异常常用try-catch，运行时异常少用
* try-catch-finally通常处理编译时异常，但运行时异常仍可能报错，相当于把编译时存在的问题延迟到运行时出现
* 如果抛出了一个catch没有声明的异常，那个方法会立刻退出

### 二：throws + 异常类型
* e.g. ```class Person throws Exception {}```
* 把异常抛给方法的调用者，并没有真正处理掉异常，**意思就是自己处理不了，把异常抛向外面**
* 如果存在继承关系，可以一层一层把异常一直往上面抛。**但最终有一层一定要用try-catch来处理，不能不处理异常，不能一直推脱**
* 在方法声明处出现，此方法执行时，可能抛出异常对象
* 一旦方法体执行出现异常，仍然会在异常代码处生成一个异常类，此对象满足throws后异常类型时，就会被抛出，异常代码后续的代码不再执行
* **子类重写的方法抛出的异常类型不大于父类被重写方法抛出的异常类型**

### throws vs try-catch-finally
* 父类被重写方法没有throws，子类重写方法就不能throws，这个时候子类就只能用try-catch
* 如果几个方法有关联，每个方法都有异常可能，用throws来分别处理

### 自定义异常类型
* extend现有异常：Exception or RunTimeException
* 提供全局常量
* 提供默认构造器和重载构造器（用来放置详细信息）
* 用`throw new`来抛出
* e.g.
  ```java
  public class MyException extends RuntimeException {
    static final long serialVersionUID = -1829867L; //全局变量，序列号，可以理解为唯一标志
    public MyException() {

    }

    public MyException(String msg) {
      super(msg)
    }
  }
  ```

## relate methods
![](picture/relate_methods_throw.png)

## 再次抛出异常
![](picture/throw_exception_again.png)

## 结论

![](picture/exception_summary.png)

## try-with-resources

* 假设资源属于实现了AutoClosable接口的类,其中有一个方法
  * void close() throws Exception
* 形式
```java
try (Resource res = ...) {
  work with res
  (close automatically)
}
```
* 退出的时候自动调佣res.close()
* res可以多个，最终都会自动关

## stack trace
* `Throwable.printStackTrace()`
* StackWalker类，会生成一个`StackWalker.StackFrame`实例类，每一个分别描述一个stack frame，可以迭代处理`StackWalker w = StackWalker.getInstance(); w.forEach(frame -> analyze frame)`也可以`w.walk(stream -> process stream)`。其中一些方法可以得到执行代码的文件名、行号、对象和方法名，toString方法生成的格式化字符串包含这些信息
* 举例
  * ![](./picture/factorial_function.png)
  * ![](./picture/factorial_res.png)

## 常见方法

![](./picture/exception_methods.png)
![](./picture/exception_methods_2.png)

## 使用异常的技巧
* 异常处理不能代替简单测试，能用if检测的就别用异常处理了，只有异常情况下在使用异常处理
* 不要过度细化异常，否则代码太多
* 多用异常层次结构，比如创造合适的子类或者自己的异常类，不要为逻辑错误抛出异常，如果能将一个异常转换成另一种更合适的异常不要犹豫
* 不要压制异常
* 早抛出，晚捕获

## debug技巧

* 打印，比如println，比如Logger.getGlobal().info(...)
* 每一个类可以都放一个main用来debug
* JUnit
* 日志代理logging proxy是子类的对象，截获方法调用，记录日志，然后调用超类中的方法