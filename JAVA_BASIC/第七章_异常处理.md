# 第七章 异常处理

## 概述

* **理解**
  * 遇到各种出现的问题，可以自己写报错内容
  * 执行程序中的不正常现象称为异常
  * 异常事件分类
    * Error
      * 虚拟机无法解决的严重问题，一般无法自行解决
      * 一般不进行代码处理
      * 举例
        * java.lang.StackOverFlowError - stack
        * java.lang.OutOfMemoryError - heap
        * 资源耗尽
        * JVM系统内部错误
    * Exception
      * 因为编程错误或者偶然外在因素导致的一般性问题，可以使用针对性代码处理
      * 举例
        * 空指针访问
        * 数组角标越界
        * 读取不存在的文件
        * 网络连接中断
  * 解决方案
    * 方法一
      * 终止运行
    * 方法二
      * 编写程序，考虑到错误的检测或者错误消息的提示，或者错误的处理
  * 捕获错误
    * 最好在编译期间，但有的只能在运行时出现
    * 分类
      * 编译时异常
      * 运行时异常

## 异常结构体系

* Throwable
  * Error
  * Exception
    * checked 编译异常
      * IOException
        * FileNotFoundException
      * ClassNotFound
    * unchecked 运行异常
      * NullPointerException
      * ArrayIndexOutOfBoundsException
      * ClassCastException
      * NumberFormatException
      * InputMismatchException
      * ArithmeticException

## 常见异常举例

```java
// NullPointerException
int[] arr = null;
sout(arr);

// InputMismatchException
Scanner s = new Scanner(System.in);
int score = sacnner.nextInt();//input abc
sout(score);

// NumberFormatException
String str = "abc";
int num = Integer.parseInt(str);

//ArithmeticException
int i = 10 / 0;

// FileNotFoundException
File f = new File("hello.txt");
FileInputStream fis = new FileInputStream(file);

int data = fis.read();
while(data != -1) {
    sout((char)data);
    data = fis.read();
}

fis.close();
```

## 异常处理机制

异常 - 异常代码生成一个对应异常类 - 抛出 - 之后代码不执行

### 一：try-catch-finally

```java
try{
    //possible code creating exception
} catch(Exception1 var1) {
    //handle 1
    sout("Exception1: ...");
} catch(Exception2 var2) {
    //handle 2
}
...
finally{
    // code that would be implemented
    // Optional
    sout("End of the Program");
}
```
* 一旦出现异常并被catch抓住，就跳出结构（除非有finally),继续执行其他代码
* 如果异常有父子类关系，子类一定要在上面，否则报错（没有父子关系，则谁在上运行谁）
* 打印异常
  * 自己写
  * `sout(e.getMessage())`
  * `e.printStackTrace()`
* finally - 最后一定执行的代码
  * 数据库连接、输入输出流、网络编程socket等资源，jvm不能自动回收的，需要手动回收资源释放 - finally
* 该结构可以嵌套写，比如finally里可以继续写try-catch
* 编译时异常常用try-catch，运行时异常少用
* try-catch-finally通常处理编译时异常，但运行时异常仍可能报错，相当于把编译时存在的问题延迟到运行时出现

### 二：throws + 异常类型

