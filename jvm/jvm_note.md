# JVM笔记 -- 《深入理解java虚拟机：JVM高级特性与最佳实践》

## 第二章 java内存区域与内存溢出异常

### 运行时数据区域

#### 内存数据区域结构

![](./jvm_pic/data_area.png)

#### 程序计数器 Program Counter Register（PCR）

* **定义与特点**
  * 很小的内存区域
  * **当前线程所执行的字节码行号指示器** - 改变计数器数值选取下一行要执行的字节码指令
  * **线程私有** - 生命周期与线程相同
* **作用**
  * 线程切换的时候，通过计数器能准确回到需要执行的字节码的位置，因此每个线程需要一个独立的PCR
* **数值如何改变**
  * 执行java程序 - 计数器数值是正要执行的字节码指令的地址；执行本地方法 - 计数器数值是空（underfined）
* **异常状况**
  * 唯一一个在《java虚拟机规范》**没有规定任何OutOfMemoryError**情况的区域

#### 虚拟机栈（JAVA Virtual Machine Stack）

* **定义与特点**
  * **线程私有** - 生命周期与线程相同
  * java方法执行的线程内存模型
* **作用**
  * 每个方法执行的时候，虚拟机会**同步创建一个栈帧（stack frame）**，用来**存储局部变量表、操作数栈、动态连接、方法出口**等信息。每个方法调用都是一个栈帧在虚拟机栈中入栈和出栈的过程
  * **局部变量表**
    * 提到栈的时候经常特指局部变量表
    * 存放**java虚拟机基本数据类型、对象引用（句柄或者引用指针或其他跟对象位置有关的）、returnAddress类型**（下一条字节码指令的地址）
    * 这些数据类型的存储空间在局部变量表中**用局部变量槽（slot）来表示**。除了64位的double和long一般占两个槽，其他都是一个槽
    * 局部变量表的内存空间在编译期间完成分配，因此进入方法时栈帧要分配给局部变量表的内存空间是完全确定的，**运行期间也不会改变大小**
* 异常状况
  * **StackOverFlowError** - 线程请求的栈深度超过虚拟机允许的栈深度时
  * **OutOfMemoryError** - 如果虚拟机栈可以动态扩展，栈扩展申请不到足够内存时
    * **HotSpot虚拟机不能动态扩展**，因此不存在动态扩展申请不到足够内存抛出OOM异常，只可能是线程一开始申请栈空间就没申请到足够内存空间时抛出OOM异常

#### 本地方法栈 (Native method stacks)

* **定义与特点**
  * **线程私有** - 生命周期与线程相同
* **作用**
  * 与虚拟机栈作用类似
  * 与虚拟机栈作用区别
    * 虚拟机栈为虚拟机执行java方法（字节码）服务
    * 本地方法栈**为虚拟机执行本地方法服务**
  * HotSpot虚拟机直接将本地方法栈与虚拟机栈合二为一，因为规范中没有强制规定
* **异常状况**
  * 同虚拟机栈 - **OutOfMemoryError & StackOverFlowError**

#### JAVA堆 （JAVA Heap）

* **定义与特点**
  * 虚拟机管理的内存中最大的一块
  * **线程共享** - 虚拟机启动时创建
  * **垃圾回收器管理的内存区域** - GC堆
  * 可以处于**物理上不连续**的内存空间中，但在**逻辑上**它应该被视为**连续**的
  * **可以被实现成固定大小，或者可扩展**，但当今**主流java虚拟机**都是按照**可扩展实现**的（设定参数-Xmx，-Xms）
* **作用**
  * **存放实例对象**
  * 回收内存角度 - 分成新生代、老年代、永久代、eden空间等等
  * 内存分配角度 - 分成若干个线程私有的分配缓冲区（Thread Local Allocation Buffer， TLAB）
  * 以上角度的堆细分只是为了更高效地回收和分配内存，java堆唯一目的就是存放实例对象
* 异常状况
  * 没内存完成实例分配 & 无法扩展 - **OutOfMemoryError**

#### 方法区（Method Area）

* **定义与特点**
  * **线程共享**
  * 规范中描述为堆的一个逻辑部分，但有别名”非堆“（Non-Heap）
  * **不需要连续内存**
  * 实现可以选择**固定大小或者可扩展**，甚至可以**选择不实现垃圾收集**
  * 内存回收一**般针对常量池回收和对类型的卸载**，但**回收效果一般难令人满意**，但有时这个区域回收确实必要
* 作用
  * 用于存储已被虚拟机加载的**类型信息、常量、静态变量、即时编译器编译后的代码缓存等**数据
* 异常状况
  * 无法满足新的内存分配 - **OutOfMemoryError**

#### 运行时常量池（Runtime Constant Pool）

* 定义与特点
  * 方法区的一部分
  * Class文件中存放除了类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表（Constant Pool Table），用于存放编译器生成的各种字面量和符号引用，类加载后这部分内容会存放到运行时常量池中
  * **动态性 - 运行期间也可以有新的常量放入池中** e.g. String类的intern()方法
* 作用
  * 类加载后**存储Class文件中常量池内容（字面量、符号引用）**，一般来说**也存储由符号引用翻译的直接引用**，**运行期间也有新的常量存入**
* 异常状况
  * 无法申请到内存 - **OutOfMemoryError**

#### 直接内存（Direct Memory）

* **定义与特点**
  * 不是虚拟机运行时数据区域一部分，也不是java虚拟机规范定义的内存区域
  * 但被**频繁使用**
  * **受到本机总内存大小**（包括**物理内存、SWAP分区或者分页文件**）以及**处理器选址空间的限制**
* **作用**
  * 可以被分配内存（属于对外内存）
* **异常状况**
  * 配置虚拟机参数时，会根据实际内存设置-Xmx等参数，但**经常忽略直接内存，导致各个内存区域综合大于物理内存限制**（包括物理和操作系统级的限制） - 动态扩展时 - **OutOfMemoryError**

### HotSpot虚拟机对象探秘

#### 对象创建

* **类加载检查**
  * 遇到一条字节码new指令时，首先检查该指令的参数是否能在常量池中定位到一个类的符号引用，检查这个符号引用代表的类是否已被加载、解析和初始化过，若没有，则需要类加载过程的执行
* **新生对象分配内存**
  * 对象所需内存大小在类加载完成后完全确定
  * **分配方法**
    * **堆内存规整 - 指针碰撞（Bump The Pointer）**- 只需要指针向空闲空间方向挪动一段与对象大小相等的距离
    * **堆内存不规整 - 空闲列表维护（Free List）** - 记录哪些内存块可用，划出去给实例了就更新列表
    * 使用哪种方法根据gc是否有空间压缩整理能力（Compact）
  * 并发如何保证**线程安全**
    * 方法一：对分配内存空间的动作进行同步处理 - CAS + 失败重试
    * 方法二：每个线程在堆上都有**本地线程分配缓冲（TLAB**），线程先在自己的本地缓冲区分配内存，不够了需要分配新的缓存区才需要同步锁定 - 参数： -XX: +/-UseTLAB
* **分配的内存空间（不包括对象头）都初始化为零值**
  * 如果使用了TLAB，可以提前到TLAB分配时顺便初始化
  * 保证了对象实例字段在java代码中可以**不赋初始值即可直接使用**，访问到字段的**数据类型对应的零值**
* **对对象必要的设置并存放在对象的对象头（Object Header）**
  * 例如：哪个对象的实例，如何找到类的元数据信息，对象的hashcode，对象的gc分代年龄等
* **（java程序视角）执行class文件中的< init >()方法来初始化**
  * 虚拟机角度 - 前四个步骤已经产生新的对象；java程序视角 - 构造函数刚开始建造对象
  * 一般来说，new指令之后执行< init >()方法，按照程序员的意愿对对象进行初始化，这样一个真正可用对象才完全被构造出来

#### 对象内存布局(Hotspot)

* 对象在内存中的存储布局分三个部分
  * **对象头（Header）**
  * **实例数据（Instantce data）**
  * **对齐填充（Padding）**
* **对象头 - 存储两类信息**
  * **Mark Word**
    * 用于存储对象自身的运行时数据，比如hashcode、gc分代年龄、锁状态信息、线程持有的锁、偏向线程id、偏向时间戳等
    * 动态定义的数据结构 - 在极小空间存储尽量多的数据，并且根据对象状态复用空间
  * **类型指针**
    * 对象指向它的类型元数据的指针
    * 用来确认对象为哪个类的实例
  * 如果对象是**java数组，还需一块记录数组长度的数据** - java对象元数据可以判断对象大小，但如果数组长度不确定就无法推断数组大小
* **实例数据**
  * 对象真正存储的有效数据 - 定义的各种类型的字段内容（父类继承以及子类定义的）
  * **存储顺序** - 受虚拟机分配策略参数和字段在源码定义顺序影响
    * **Hotspot默认分配顺序 - 相同宽度字段分配到一起存放，在该前提下，父类中定义的变量出现在子类之前**
* **对齐填充**
  * 非必然存在，仅仅是起占位符作用
  * HotSpot的自动内存管理系统要求**对象起始地址必须是8字节的整数倍，即任何对象大小都是8字节的整数倍**，所以**对象头**已经被精心设计成正好是**8字节的倍数（1-2倍）**，如果实例数据部分没有对齐就用对齐填充来补全

#### 对象访问定位

* 如何定位
  * java程序通过**栈上的reference数据来操控堆的对象**
* 实现reference来访问的方法
  * **句柄**
    * java堆上可能划分出一块内存作为句柄池，reference存储的就是对象的句柄地址 - 包括：**对象实例数据地址 + 对象类型数据地址**
    * 优势
      * reference存储的是稳定句柄池地址，对象被移动时（比如垃圾回收时）不会改变reference中的值，只改变句柄里实例数据指针
    * ![](./jvm_pic/jubing.png)
  * **直接指针**
    * reference存储的**直接就是对象实例数据地址，对象内存布局里存有访问类型数据的相关信息**
    * HotSpot使用该方法访问对象
    * 优势
      * 快捷，省去一次指针定位的时间开销
    * ![](./jvm_pic/zhijiezhizhen.png)

## 第三章 垃圾收集器与内存分配策略

### 为什么需要了解垃圾收集和内存分配
* 垃圾收集GC需要完成三件事：**哪些内存需回收？啥时候回收？如何回收？**
* 当需要排查内存泄漏、溢出问题时，或者垃圾收集称为系统达到更高并发量的瓶颈中，我们就必须对其技术实施进行**必要的监控和调节**
* 不需要过多考虑回收的区域
  * 程序计数器、虚拟机栈、本地方法栈 - 生命周期与线程一样，栈帧大小一开始类结构确定时就已知，然后随方法入栈出栈，因此内存分配回收具有确定性，当方法结束或者线程结束，内存自然跟随回收
* **需要考虑垃圾回收的区域**
  * **java堆和方法区** - 处于运行期间，内存分配和回收是动态的 - **显著的不确定性**

### 如何判断对象死亡
* 死去 - 即不可能被任何途径使用的对象

#### 引用计数算法（Reference Counting）
* 原理
  * 在对象中添加一个引用计数器，**每当有一个地方引用它，计数器++；引用失败，计数器--；任何时刻计数器==0的对象不可能再被使用**
* 优势
  * 虽然占用额外内存空间计数，但原理简单，判定效率高，多数情况效果不错
* 劣势
  * 需要考虑很多例外情况，必须配合大量额外处理才能保证正确地工作 - e.g.**单纯引用计数很难解决对象间相互循环引用问题**
* 应用
  * 主流java虚拟机都不选择该算法

#### 可达性分析算法（Reachability Analysis）
* 原理
  * 通过一系列**称为“GC Roots”的根对象**作为起始节点集，在这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径**称为“引用链”（Reference Chain）**，如果一个对象到gc roots间没有任何引用链相连，或者用图论的话说就是**从gc roots到对象不可达**，则该对象不可能再被使用
  * e.g.
    * ![](./jvm_pic/reachablity_analysis.png)
  * 可作为gc roots的对象
    * **虚拟机栈（栈帧中的本地变量表）中引用的对象** - e.g. 各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等
    * **方法区中类静态属性引用的对象** - e.g.java类的引用类型静态变量
    * **方法区常量引用的对象** - e.g.字符串常量池（String Table）里的应用
    * 本地方法栈中JNI（**native方法）引用**的对象
    * **Java虚拟机内部的引用** - e.g.基本数据类型对应的Class对象，一些常驻异常对象（OutOfMemoryError、NullPointException等），系统类加载器
    * 所有**被同步锁（synchronized关键词）持有**的对象
    * 反映java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等
  * 根据所选垃圾收集器以及当前回收的内存区域不同，也有其他对象“临时性”加入gc roots集合，以保证可达性分析的正确性（比如分代收集和局部回收（partial gc），某个区域的对象可能被位于堆中其他区域对象所引用，所以需要加入gc roots集合中）
* 应用
  * 当前主流使用程序语言（java、c#等）内存管理系统子系统都用该算法
  * 为避免gc roots包含过多对象导致过度膨胀，实现时做了各种优化处理

#### 引用
* JDK1.2之后，java将引用分为四种引用（**强度依次减弱**） - **强引用（Strong Reference），软引用（Soft Reference），弱引用（Weak Reference），和虚引用（Phantom Reference）**（后三种都是jdk1.2之后提供了对应类来实现 - SoftReference、WeakReference、PhantomReference）
* **强引用**
  * 最传统的引用定义 - `Object obj = new Object()`
  * 该引用存在，该被引用对象就**永远不会被回收**
* **软引用**
  * 还**有用，但非必须对象**
  * 系统将要发生内存溢出异常前，把这些对象列进垃圾回收范围之中进行第二次回收，若垃圾回收后还是没有足够内存，才会抛出内存溢出异常
* **弱引用**
  * 非必须对象，强度比软引用更弱
  * 被引用对象**只能生存到下一次gc发生为止**，gc一旦开始就会被回收
* **虚引用（幽灵引用or幻影引用）**
  * 最弱
  * 对象添加虚引用**完全无法左右它的生存时间**，也**无法通过该引用获得实例**
  * 唯一目的只是该对象**回收时收到一个系统通知**

#### 判定不可达后是否真正死亡（回收）
* 真正死亡需要**至少经历两次标记过程**
  * **第一次标记**：对象进行可达性分析后发现没有与gc roots相连接的引用链
  * **第二次标记**：先进行一次筛选，条件是该对象是否有必要执行`finalize()`方法
    * **假如对象没有覆盖`finalize()` or `finalize()`已经被虚拟机调用过 - 虚拟机视为“没有必要执行`finalize()`”**
    * 反之，“有必要执行`finalize()`”，该对象放入一个名为**F-Queue队列**中，并在稍后由一条虚拟机自动建立、低调度优先级的Finalizer线程去执行它们的`finalize()`方法，该执行指的是虚拟机会触发这个方法开始运行，但不承诺一定等它运行结束
      * 原因：如果某对象`finalize()`执行缓慢，或者更极端发生了死循环，那F-Queue队列中其他对象永久处于等待，甚至导致整个内存回收子系统的崩溃。
    * 稍后收集器会对F-Queue的对象进行**第二次小规模标记**。若对象`finalize()`成功让自己和引用链上的任何对象建立关联即可拯救成功（e.g. 自己（this关键词）赋值给某个类变量或对象的成员变量），就会被第二次标记时被移出“即将回收”的集合。
    * `finalize()`是**对象逃脱死亡最后的机会**，一个对象自救的`finalize()`**最多只会被系统自动调用一次**。
* 两次标记后，在集合中的对象就基本上要真回收了
* 尽量避免使用`finalize()`
  * 运行代价高昂，不确定性大，无法保证各个对象的调用顺序，**官方声明不推荐使用** - try-finally或其他可以做的更好、更及时

#### 回收方法区
* 垃圾收集器可以选择不实现对方法区的回收或者部分回收，因为方法区回收“性价比”较低，在**回收判断条件苛刻的情况下，回收效果不佳**。
* 方法区回收有两个部分
  * **废弃常量**
    * 条件相对简单
    * 回收判断条件：类似堆对象回收，若**没有任何对象或者虚拟机其他地方引用该常量**（比如常量池的某个字面量或者符号引用），该常量可以被系统清理出常量池
  * **不再使用的类型**
    * 条件相对苛刻
    * **回收判断条件**（要同时满足三条，满足后仅仅是“被允许对类进行回收”，而不是像对象一样没有引用就必然回收）：
      * 该类型**所有实例都被回收**了，堆里**不存在该类以及任何派生子类的实例**
      * **加载该类的类加载器已经被回收**，除非是经过精心设计的可替换类加载器的场景，比如OSGi、JSP的重加载等，否则通常很难达成
      * **该类对应的`java.lang.Class`对象没有在任何地方被应用**，无法在任何地方通过反射访问该类的方法

### 垃圾收集算法
* 根据配合判断对象死亡角度，垃圾收集算法划分为
  * 引用计数式垃圾收集（ReferenceCountingGC） - 直接垃圾收集
  * 追踪式垃圾收集（TracingGC） - 间接垃圾收集 - 属于主流Java虚拟机使用的垃圾收集算法

#### 分代收集理论（Generational Collection）
* **理论**（实际是符合大多数程序运行实际情况的经验法则）
  * 当前商业虚拟机垃圾收集器大多都遵循该理论
  * **两个分代假说**
    * **弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕死**
    * **强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾回收过程的对象越难以消化**
  * 基于上述假说的**设计原则**
    * 收集器将java堆划分为不同区域，将回收对象依据其年龄（熬过垃圾收集过程的次数）分配到不同区域存储
    * **好处**
      * 省时间，低代价回收大量空间，空间获得有效利用
      * 分为不同区域后，垃圾收集器就可以每次只回收其中一个或某些部分的区域，才能针对不同区域安排与里面存储对象存亡特点相匹配的垃圾收集算法
    * 现在商用java虚拟机，**一般至少把堆划分为新生代（Young Generation）和老年代（Old Generation）**
      * 每次有大批对象死在新生代，少部分存活下来的会逐步晋升到老年代存放
  * **第三条假说（经验法则）**
    * **出现原因**：**对象间可能会存在跨代引用**
    * 跨带引用可能引起的**后果**：假如只局限新生代的收集，但新生代对象可能被老年代对象引用，为了找出该区域存货对象，不得不在固定GC Roots之外，额外遍历整个老年代的对象老保证可达性分析的正确性 - 巨大性能负担。反之亦然。
    * **假说内容：跨代引用相对于同代引用仅占极少数**
    * 由上述两个假说得到的**隐含推论：存在互相引用关系的两个对象应该倾向于同时生存或者消亡** - 新生代对象有跨代引用 -> 老年代对象难消亡 -> 新生代对象因为该引用得以存活 -> 年龄增长，晋升老年代 -> 跨代引用消除
  * 根据第三条假说进行的针对跨代引用的**设计原则**
    * **只需在新生代上建立一个全局数据结构（记忆集Remembered Set）**，该结构把老年代划分为若干小块，标识**出老年代哪一内存会存在跨代引用**
    * 之后发生minor gc，只有包含跨代引用的小块内存的对象被放进gc roots里进行扫描
    * 好处
      * 虽然需要在对象改变引用关系（比如自己或者某个属性赋值）时维护记录数据的正确性而增加一点运行时开销，但比收集时扫描整个老年代划算
  * **部分回收（Partial GC）**
    * 目标不是完整收集整个java堆的垃圾收集
    * **分类**
      * 新生代收集(Minor GC/Young GC)
      * 老年代收集（Major GC/Old GC）：目前只有CMS收集器有单独收集老年代的行为
      * 混合收集（Mixed GC）：收集整个新生代+部分老年代。目前只有G1收集器有这个行为
      * 整堆收集（Full GC）：收集整个java堆和方法区

#### 标记-清除算法（Mark-Sweep）
* 原理
  * 两个阶段-标记+清除：标记所有需要回收对象然后统一回收被标记对象/标记所有存活对象然后统一回收未被标记对象（标记过程-判定是否为垃圾/死亡的过程）
* 特点
  * 最基础算法，后续算法都是以此为基础，改进其缺点
* 缺点
  * 执行效率不稳定 - 如果有大量对象且大部分需要回收，必须进行大量标记和清除动作 - 对象越多，执行效率越低
  * 内存空间碎片化问题 - 产生大量不连续内存碎片，导致之后运行过程要分配大对象时找不到足够的连续内存，不得不提前触发另一次垃圾收集动作

#### 标记-复制算法

#### 标记-整理算法

### HotSpot算法细节实现

### 经典垃圾收集器

### 低延迟垃圾收集器

### 如何选择合适的垃圾收集器

### 实战：内存分配与回收策略
